<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>GP Local Demo Test</title>
  <style>body{font-family:system-ui;padding:18px;background:#0f1720;color:#e6eef8}input,textarea,button{font:15px/1.2 system-ui;padding:8px;border-radius:6px}textarea{width:100%;height:120px}button{cursor:pointer}#status{margin-top:12px;color:#bfe9d7}</style>
</head>
<body>
  <h2>GhostPass — Local Capture Test</h2>
  <p>This runs fully local — no server. Use it to prove Start/Stop capture works.</p>

  <div>
    <label>User ID: <input id="userId" placeholder="alice"></label>
    <button id="start">Start Capture</button>
    <button id="stop" disabled>Stop Capture</button>
  </div>

  <div style="margin-top:12px">
    <textarea id="box" placeholder="Click Start, then type here..."></textarea>
  </div>

  <div style="margin-top:8px">
    <button id="enroll">Enroll (local)</button>
    <button id="verify">Verify (local)</button>
    <span id="count" style="margin-left:12px">Keystrokes: 0</span>
  </div>

  <div id="status">Status: idle</div>

<script>
(function(){
  // super-simple, self-contained capture demo
  const startBtn = document.getElementById('start');
  const stopBtn  = document.getElementById('stop');
  const enrollBtn = document.getElementById('enroll');
  const verifyBtn = document.getElementById('verify');
  const box = document.getElementById('box');
  const countEl = document.getElementById('count');
  const status = document.getElementById('status');
  const userIdInput = document.getElementById('userId');

  let running = false;
  let events = [];
  const ign = new Set(['Shift','Control','Alt','Meta','CapsLock','Escape']);

  function updateCount(){ countEl.textContent = 'Keystrokes: ' + events.length; }

  function onKD(e){
    if(ign.has(e.key)) return;
    events.push({t:Date.now(), k:e.code||e.key, d:'down'});
    updateCount();
  }
  function onKU(e){
    if(ign.has(e.key)) return;
    events.push({t:Date.now(), k:e.code||e.key, d:'up'});
    updateCount();
  }

  window.startCapture = function(){
    if(running) return;
    events = [];
    box.addEventListener('keydown', onKD, {passive:true});
    box.addEventListener('keyup', onKU, {passive:true});
    running = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;
    status.textContent = 'Status: capturing — type in the box';
    box.focus();
    console.log('capture started');
  };

  window.stopCapture = function(){
    if(!running) return;
    box.removeEventListener('keydown', onKD);
    box.removeEventListener('keyup', onKU);
    running = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    status.textContent = 'Status: stopped — captured ' + events.length + ' events';
    console.log('capture stopped', events.length, events.slice(0,6));
  };

  startBtn.onclick = window.startCapture;
  stopBtn.onclick = window.stopCapture;

  // local enroll/verify (client side only)
  const localProfiles = {};
  enrollBtn.onclick = function(){
    const user = (userIdInput.value||'').trim();
    if(!user){ alert('enter a user id'); return; }
    if(events.length < 8){ alert('type at least 8 keys before enroll'); return; }
    // compute simple profile (mean hold & mean iki)
    function extract(events){
      const down = new Map(), holds=[], presses=[];
      for(const e of events){
        if(e.d==='down'){ if(!down.has(e.k)) { down.set(e.k,e.t); presses.push(e.t); } }
        else if(e.d==='up'){ const t0=down.get(e.k); if(t0!=null){ holds.push(e.t-t0); down.delete(e.k); } }
      }
      const iki = []; for(let i=1;i<presses.length;i++) iki.push(presses[i]-presses[i-1]);
      const stats = arr=>{ if(!arr.length) return {mean:0,std:0}; const m=arr.reduce((a,b)=>a+b,0)/arr.length; const s=Math.sqrt(arr.reduce((acc,x)=>acc+(x-m)*(x-m),0)/Math.max(1,arr.length-1)); return {mean:m,std:s}; };
      return {vec:[stats(holds).mean, stats(holds).std, stats(iki).mean, stats(iki).std], n:{ht:holds.length, iki:iki.length}};
    }
    localProfiles[user] = extract(events);
    status.textContent = `Enrolled (local) ${user} — saved profile`;
    console.log('enrolled profile for',user, localProfiles[user]);
    events = []; updateCount(); box.value=''; window.stopCapture();
  };

  verifyBtn.onclick = function(){
    const user = (userIdInput.value||'').trim();
    if(!user){ alert('enter a user id'); return; }
    if(events.length < 8){ alert('type at least 8 keys before verify'); return; }
    if(!localProfiles[user]){ status.textContent = `No profile for ${user} — enroll first`; return; }

    // compare simple cosine as in server
    function cosine(a,b){ let dp=0,na=0,nb=0; for(let i=0;i<a.length;i++){ dp+=a[i]*b[i]; na+=a[i]*a[i]; nb+=b[i]*b[i]; } if(na===0||nb===0) return 0; return dp/(Math.sqrt(na)*Math.sqrt(nb)); }
    const sample = (function(){ // reuse extractor
      const down = new Map(), holds=[], presses=[];
      for(const e of events){ if(e.d==='down'){ if(!down.has(e.k)){ down.set(e.k,e.t); presses.push(e.t);} } else if(e.d==='up'){ const t0=down.get(e.k); if(t0!=null){ holds.push(e.t-t0); down.delete(e.k);} } }
      const iki=[]; for(let i=1;i<presses.length;i++) iki.push(presses[i]-presses[i-1]);
      const stats = arr=>{ if(!arr.length) return {mean:0,std:0}; const m=arr.reduce((a,b)=>a+b,0)/arr.length; const s=Math.sqrt(arr.reduce((acc,x)=>acc+(x-m)*(x-m),0)/Math.max(1,arr.length-1)); return {mean:m,std:s}; };
      const h=stats(holds), ik=stats(iki); return {vec:[h.mean,h.std,ik.mean,ik.std], n:{ht:holds.length, iki:iki.length}}; })();

    const prof = localProfiles[user];
    const sim = cosine(prof.vec, sample.vec);
    const coverage = Math.min(1, (sample.n.ht+sample.n.iki) / Math.max(1,(prof.n.ht+prof.n.iki)/2));
    const score = Math.max(0, Math.min(1, 0.85*sim + 0.15*coverage));
    status.textContent = `Verified local for ${user}: score=${score.toFixed(3)} (sim=${sim.toFixed(3)})`;
    console.log('verify sample', sample, 'profile',prof, 'score',score);
    events = []; updateCount(); box.value=''; window.stopCapture();
  };

  function updateCount(){ countEl.textContent = 'Keystrokes: ' + events.length; }
  // events is closed over; update UI periodically
  setInterval(()=>{ document.getElementById('count').textContent = 'Keystrokes: ' + events.length; }, 200);

  // expose for debugging
  window._gp_local = { start: window.startCapture, stop: window.stopCapture, events, profiles: localProfiles };
  console.log('local demo ready. Use Start Capture to begin.');
})();
</script>
</body>
</html>
